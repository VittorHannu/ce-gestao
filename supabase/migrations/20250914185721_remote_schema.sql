create extension if not exists "unaccent" with schema "public";

create type "public"."approval_status" as enum ('pendente', 'aprovado', 'reprovado');

create sequence "public"."audit_logs_id_seq";

create sequence "public"."relato_seq";


  create table "public"."audit_logs" (
    "id" bigint not null default nextval('audit_logs_id_seq'::regclass),
    "created_at" timestamp with time zone not null default now(),
    "user_id" uuid,
    "action" text not null,
    "table_name" text,
    "record_id" uuid,
    "old_record" jsonb,
    "new_record" jsonb,
    "ip_address" inet
      );


alter table "public"."audit_logs" enable row level security;


  create table "public"."feedback_reports" (
    "id" uuid not null default gen_random_uuid(),
    "created_at" timestamp with time zone not null default now(),
    "user_id" uuid,
    "report_type" text not null,
    "subject" text,
    "description" text not null,
    "status" text not null default 'PENDENTE'::text
      );


alter table "public"."feedback_reports" enable row level security;


  create table "public"."profiles" (
    "id" uuid not null,
    "email" text not null,
    "full_name" text,
    "is_active" boolean default true,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "can_manage_relatos" boolean default false,
    "can_view_users" boolean default false,
    "can_create_users" boolean default false,
    "can_delete_users" boolean default false,
    "can_view_feedbacks" boolean default false,
    "can_delete_relatos" boolean default false,
    "can_manage_users" boolean default false,
    "can_delete_any_comment" boolean default false,
    "can_view_all_relatos" boolean not null default false,
    "can_view_audit_logs" boolean not null default false
      );


alter table "public"."profiles" enable row level security;


  create table "public"."relato_comentarios" (
    "id" uuid not null default gen_random_uuid(),
    "relato_id" uuid not null,
    "user_id" uuid,
    "comment_text" text not null,
    "created_at" timestamp with time zone default now()
      );


alter table "public"."relato_comentarios" enable row level security;


  create table "public"."relato_logs" (
    "id" bigint generated by default as identity not null,
    "relato_id" uuid not null,
    "user_id" uuid,
    "action_type" text not null,
    "details" jsonb,
    "created_at" timestamp with time zone not null default now()
      );


alter table "public"."relato_logs" enable row level security;


  create table "public"."relato_responsaveis" (
    "relato_id" uuid not null,
    "user_id" uuid not null,
    "created_at" timestamp with time zone default now()
      );


alter table "public"."relato_responsaveis" enable row level security;


  create table "public"."relatos" (
    "id" uuid not null default gen_random_uuid(),
    "created_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "user_id" uuid,
    "is_anonymous" boolean default false,
    "local_ocorrencia" text not null,
    "data_ocorrencia" date not null,
    "hora_aproximada_ocorrencia" time without time zone,
    "descricao" text not null,
    "riscos_identificados" text not null,
    "danos_ocorridos" text,
    "status" text not null default 'PENDENTE'::text,
    "planejamento_cronologia_solucao" text,
    "data_conclusao_solucao" date,
    "relato_code" text,
    "tipo_relato" text,
    "concluido_sem_data" boolean default false
      );



  create table "public"."tmp_relato_tipo" (
    "id" uuid not null,
    "tipo_relato" text
      );


alter sequence "public"."audit_logs_id_seq" owned by "public"."audit_logs"."id";

CREATE UNIQUE INDEX audit_logs_pkey ON public.audit_logs USING btree (id);

CREATE UNIQUE INDEX feedback_reports_pkey ON public.feedback_reports USING btree (id);

CREATE INDEX idx_audit_logs_action ON public.audit_logs USING btree (action);

CREATE INDEX idx_audit_logs_created_at ON public.audit_logs USING btree (created_at);

CREATE INDEX idx_audit_logs_table_record ON public.audit_logs USING btree (table_name, record_id);

CREATE INDEX idx_audit_logs_user_id ON public.audit_logs USING btree (user_id);

CREATE UNIQUE INDEX profiles_email_key ON public.profiles USING btree (email);

CREATE UNIQUE INDEX profiles_pkey ON public.profiles USING btree (id);

CREATE UNIQUE INDEX relato_comentarios_pkey ON public.relato_comentarios USING btree (id);

CREATE UNIQUE INDEX relato_logs_pkey ON public.relato_logs USING btree (id);

CREATE UNIQUE INDEX relato_responsaveis_pkey ON public.relato_responsaveis USING btree (relato_id, user_id);

CREATE UNIQUE INDEX relatos_pkey ON public.relatos USING btree (id);

CREATE UNIQUE INDEX relatos_relato_code_key ON public.relatos USING btree (relato_code);

CREATE UNIQUE INDEX tmp_relato_tipo_pkey ON public.tmp_relato_tipo USING btree (id);

alter table "public"."audit_logs" add constraint "audit_logs_pkey" PRIMARY KEY using index "audit_logs_pkey";

alter table "public"."feedback_reports" add constraint "feedback_reports_pkey" PRIMARY KEY using index "feedback_reports_pkey";

alter table "public"."profiles" add constraint "profiles_pkey" PRIMARY KEY using index "profiles_pkey";

alter table "public"."relato_comentarios" add constraint "relato_comentarios_pkey" PRIMARY KEY using index "relato_comentarios_pkey";

alter table "public"."relato_logs" add constraint "relato_logs_pkey" PRIMARY KEY using index "relato_logs_pkey";

alter table "public"."relato_responsaveis" add constraint "relato_responsaveis_pkey" PRIMARY KEY using index "relato_responsaveis_pkey";

alter table "public"."relatos" add constraint "relatos_pkey" PRIMARY KEY using index "relatos_pkey";

alter table "public"."tmp_relato_tipo" add constraint "tmp_relato_tipo_pkey" PRIMARY KEY using index "tmp_relato_tipo_pkey";

alter table "public"."audit_logs" add constraint "audit_logs_action_check" CHECK ((char_length(action) > 0)) not valid;

alter table "public"."audit_logs" validate constraint "audit_logs_action_check";

alter table "public"."audit_logs" add constraint "audit_logs_user_id_fkey" FOREIGN KEY (user_id) REFERENCES profiles(id) ON DELETE SET NULL not valid;

alter table "public"."audit_logs" validate constraint "audit_logs_user_id_fkey";

alter table "public"."feedback_reports" add constraint "check_report_type" CHECK ((report_type = ANY (ARRAY['feedback'::text, 'bug'::text, 'suggestion'::text]))) not valid;

alter table "public"."feedback_reports" validate constraint "check_report_type";

alter table "public"."feedback_reports" add constraint "feedback_reports_user_id_fkey" FOREIGN KEY (user_id) REFERENCES profiles(id) ON DELETE SET NULL not valid;

alter table "public"."feedback_reports" validate constraint "feedback_reports_user_id_fkey";

alter table "public"."profiles" add constraint "profiles_email_key" UNIQUE using index "profiles_email_key";

alter table "public"."profiles" add constraint "profiles_id_fkey" FOREIGN KEY (id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."profiles" validate constraint "profiles_id_fkey";

alter table "public"."relato_comentarios" add constraint "relato_comentarios_relato_id_fkey" FOREIGN KEY (relato_id) REFERENCES relatos(id) ON DELETE CASCADE not valid;

alter table "public"."relato_comentarios" validate constraint "relato_comentarios_relato_id_fkey";

alter table "public"."relato_comentarios" add constraint "relato_comentarios_user_id_fkey" FOREIGN KEY (user_id) REFERENCES profiles(id) ON DELETE SET NULL not valid;

alter table "public"."relato_comentarios" validate constraint "relato_comentarios_user_id_fkey";

alter table "public"."relato_logs" add constraint "relato_logs_relato_id_fkey" FOREIGN KEY (relato_id) REFERENCES relatos(id) ON DELETE CASCADE not valid;

alter table "public"."relato_logs" validate constraint "relato_logs_relato_id_fkey";

alter table "public"."relato_logs" add constraint "relato_logs_user_id_fkey" FOREIGN KEY (user_id) REFERENCES profiles(id) ON DELETE SET NULL not valid;

alter table "public"."relato_logs" validate constraint "relato_logs_user_id_fkey";

alter table "public"."relato_responsaveis" add constraint "relato_responsaveis_relato_id_fkey" FOREIGN KEY (relato_id) REFERENCES relatos(id) ON DELETE CASCADE not valid;

alter table "public"."relato_responsaveis" validate constraint "relato_responsaveis_relato_id_fkey";

alter table "public"."relato_responsaveis" add constraint "relato_responsaveis_user_id_fkey" FOREIGN KEY (user_id) REFERENCES profiles(id) ON DELETE CASCADE not valid;

alter table "public"."relato_responsaveis" validate constraint "relato_responsaveis_user_id_fkey";

alter table "public"."relatos" add constraint "relatos_relato_code_key" UNIQUE using index "relatos_relato_code_key";

alter table "public"."relatos" add constraint "relatos_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE SET NULL not valid;

alter table "public"."relatos" validate constraint "relatos_user_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.can_i_view_audit_logs()
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  has_permission BOOLEAN;
BEGIN
  SELECT can_view_audit_logs INTO has_permission
  FROM public.profiles
  WHERE id = auth.uid();
  RETURN COALESCE(has_permission, FALSE);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.check_relato_status_change()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  -- Se o status_aprovacao está sendo alterado
  IF OLD.status_aprovacao IS DISTINCT FROM NEW.status_aprovacao THEN
    -- E o usuário NÃO tem a permissão de aprovar relatos
    IF public.get_my_claim('can_approve_relatos') IS NOT TRUE THEN -- Alterado para usar a nova get_my_claim que retorna BOOLEAN
      RAISE EXCEPTION 'Permissão negada: Somente usuários com permissão de aprovação podem alterar o status do relato.';
    END IF;
  END IF;
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.check_relatos_admin_update()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    is_current_user_admin BOOLEAN;
BEGIN
    -- Corrigido: Usando is_admin_relatos em vez de is_admin
    SELECT is_admin_relatos INTO is_current_user_admin FROM public.profiles WHERE id = auth.uid();

    IF NOT is_current_user_admin THEN
        -- Check if non-admin user is trying to change admin-only fields
        IF (NEW.tipo_incidente IS DISTINCT FROM OLD.tipo_incidente) OR
           (NEW.gravidade IS DISTINCT FROM OLD.gravidade) OR
           (NEW.responsaveis IS DISTINCT FROM OLD.responsaveis) OR
           (NEW.planejamento_cronologia_solucao IS DISTINCT FROM OLD.planejamento_cronologia_solucao) OR
           (NEW.data_conclusao_solucao IS DISTINCT FROM OLD.data_conclusao_solucao)
        THEN
            RAISE EXCEPTION 'Permissão negada: Somente administradores podem alterar campos de tipo de incidente, gravidade, responsáveis, planejamento/cronologia da solução e data de conclusão da solução.';
        END IF;
    END IF;

    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.generate_relato_code()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    next_val BIGINT;
    current_year TEXT;
BEGIN
    -- Obtém o próximo valor da sequência
    SELECT nextval('relato_seq') INTO next_val;
    -- Obtém o ano atual
    SELECT to_char(now(), 'YYYY') INTO current_year;
    
    -- Formata o relato_code
    NEW.relato_code := 'REL' || current_year || LPAD(next_val::TEXT, 5, '0');
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_dashboard_stats(p_start_date date DEFAULT NULL::date, p_end_date date DEFAULT NULL::date)
 RETURNS json
 LANGUAGE plpgsql
AS $function$
DECLARE
    stats json;
BEGIN
    SELECT json_build_object(
        'totalAprovados', COUNT(*) FILTER (WHERE status = 'APROVADO'),
        'concluidos', COUNT(*) FILTER (WHERE status = 'APROVADO' AND (data_conclusao_solucao IS NOT NULL OR concluido_sem_data = TRUE)),
        'emAndamento', COUNT(*) FILTER (WHERE status = 'APROVADO' AND planejamento_cronologia_solucao IS NOT NULL AND data_conclusao_solucao IS NULL AND (concluido_sem_data IS NULL OR concluido_sem_data = FALSE)),
        'semTratativa', COUNT(*) FILTER (WHERE status = 'APROVADO' AND planejamento_cronologia_solucao IS NULL AND data_conclusao_solucao IS NULL AND (concluido_sem_data IS NULL OR concluido_sem_data = FALSE)),
        'pendenteAprovacao', COUNT(*) FILTER (WHERE status = 'PENDENTE'),
        'myRelatosCount', COUNT(*) FILTER (WHERE user_id = auth.uid())
    )
    INTO stats
    FROM public.relatos r
    WHERE (p_start_date IS NULL OR r.data_ocorrencia >= p_start_date)
      AND (p_end_date IS NULL OR r.data_ocorrencia <= p_end_date);

    RETURN stats;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_my_claim(claim text)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN nullif(current_setting('request.jwt.claims', true), '')::jsonb->claim;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_record_sem_acidentes()
 RETURNS TABLE(dias_atuais_sem_acidentes integer, recorde_dias_sem_acidentes integer, data_ultimo_acidente date)
 LANGUAGE plpgsql
AS $function$
DECLARE
    max_historical_interval INTEGER;
    current_interval INTEGER;
    last_accident_date DATE;
    accident_count INTEGER;
BEGIN
    -- Count the total number of accidents to determine if a record can even exist.
    SELECT count(*) INTO accident_count
    FROM public.relatos r
    WHERE r.tipo_relato IN ('Acidente com afastamento', 'Fatal', 'Severo');

    -- Step 1: Find the date of the last accident.
    SELECT MAX(r.data_ocorrencia) INTO last_accident_date
    FROM public.relatos r
    WHERE r.tipo_relato IN ('Acidente com afastamento', 'Fatal', 'Severo');

    -- Step 2: Calculate the current streak of days without accidents.
    IF last_accident_date IS NOT NULL THEN
        current_interval := (CURRENT_DATE - last_accident_date);
    ELSE
        -- Fallback if no accidents are recorded at all.
        -- Calculates days since the very first report of any kind.
        SELECT (CURRENT_DATE - MIN(r.created_at)::date) INTO current_interval
        FROM public.relatos r;
    END IF;

    -- Step 3: Calculate the historical record interval.
    WITH accident_dates AS (
        SELECT r.data_ocorrencia AS accident_date
        FROM public.relatos r
        WHERE r.tipo_relato IN ('Acidente com afastamento', 'Fatal', 'Severo')
        ORDER BY r.data_ocorrencia
    ),
    intervals AS (
        SELECT
            accident_date - lag(accident_date, 1) OVER (ORDER BY accident_date) AS interval_days
        FROM accident_dates
    )
    SELECT MAX(iv.interval_days) INTO max_historical_interval
    FROM intervals iv;

    -- Step 4: Define the return values with the corrected logic.
    dias_atuais_sem_acidentes := COALESCE(current_interval, 0);

    -- A record can only exist if there are at least 2 accidents to compare.
    IF accident_count < 2 THEN
        recorde_dias_sem_acidentes := 0; -- No record if less than 2 accidents
    ELSE
        -- If there are 2+ accidents, the record is the max interval between them.
        -- If max_historical_interval is null (which shouldn't happen with 2+ accidents), default to 0.
        recorde_dias_sem_acidentes := COALESCE(max_historical_interval, 0);
    END IF;

    data_ultimo_acidente := last_accident_date;

    RETURN NEXT;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_relatos_count_by_type(p_start_date date DEFAULT NULL::date, p_end_date date DEFAULT NULL::date)
 RETURNS TABLE(tipo_relato text, total_count bigint, concluido_count bigint, em_andamento_count bigint, sem_tratativa_count bigint)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    RETURN QUERY
    SELECT
        CASE
            WHEN r.tipo_relato IS NULL THEN 'Sem Classificação'
            ELSE r.tipo_relato
        END AS tipo_relato,
        COUNT(r.id) AS total_count,
        COUNT(CASE WHEN r.status = 'APROVADO' AND r.data_conclusao_solucao IS NOT NULL THEN r.id END) AS concluido_count,
        COUNT(CASE WHEN r.status = 'APROVADO' AND r.planejamento_cronologia_solucao IS NOT NULL AND r.data_conclusao_solucao IS NULL THEN r.id END) AS em_andamento_count,
        COUNT(CASE WHEN r.status = 'APROVADO' AND r.planejamento_cronologia_solucao IS NULL AND r.data_conclusao_solucao IS NULL THEN r.id END) AS sem_tratativa_count
    FROM
        public.relatos r
    WHERE
        (p_start_date IS NULL OR r.data_ocorrencia >= p_start_date)
        AND (p_end_date IS NULL OR r.data_ocorrencia <= p_end_date)
        AND r.status = 'APROVADO'
    GROUP BY
        CASE
            WHEN r.tipo_relato IS NULL THEN 'Sem Classificação'
            ELSE r.tipo_relato
        END
    ORDER BY
        total_count DESC;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_new_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  INSERT INTO public.profiles (id, email)
  VALUES (NEW.id, NEW.email);
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_new_user_or_update_profile()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  -- Check if the user already exists in public.profiles
  IF EXISTS (SELECT 1 FROM public.profiles WHERE id = NEW.id) THEN
    -- If user exists, update their full_name and email
    UPDATE public.profiles
    SET
      full_name = NEW.raw_user_meta_data->>'full_name',
      email = NEW.email
    WHERE id = NEW.id;
  ELSE
    -- If user does not exist, insert a new record
    INSERT INTO public.profiles (id, full_name, email, is_active, can_manage_relatos, can_view_users, can_create_users, can_delete_users, can_view_feedbacks, can_delete_relatos, can_manage_users)
    VALUES (
      NEW.id,
      NEW.raw_user_meta_data->>'full_name',
      NEW.email,
      TRUE, -- Default is_active to true
      FALSE, -- Default can_manage_relatos to false
      FALSE, -- Default can_view_users to false
      FALSE, -- Default can_create_users to false
      FALSE, -- Default can_delete_users to false
      FALSE, -- Default can_view_feedbacks to false
      FALSE, -- Default can_delete_relatos to false
      FALSE  -- Default can_manage_users to false
    );
  END IF;
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.has_permission(permission_name text)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  claim_value JSONB;
BEGIN
  claim_value := public.get_my_claim(permission_name);
  IF claim_value IS NULL THEN
    RETURN FALSE;
  END IF;
  RETURN claim_value::boolean;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.invalidate_user_sessions_on_profile_change()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  -- Invalida a sessão do usuário para que um novo JWT seja gerado no próximo login
  UPDATE auth.sessions
  SET invalidated_at = now()
  WHERE user_id = NEW.id;
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.is_admin()
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND can_manage_relatos = TRUE);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.jsonb_diff_val(val1 jsonb, val2 jsonb)
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
DECLARE
    result JSONB;
BEGIN
    -- Performs a FULL OUTER JOIN on the keys of both JSON objects
    -- to capture added, deleted, and modified fields in a single pass.
    SELECT jsonb_agg(
        jsonb_build_object(
            'field', COALESCE(k1, k2), -- The name of the field that changed
            'old', val1 -> COALESCE(k1, k2), -- The old value (will be null if field was added)
            'new', val2 -> COALESCE(k1, k2)  -- The new value (will be null if field was deleted)
        )
    )
    INTO result
    FROM jsonb_object_keys(val1) k1
    FULL OUTER JOIN jsonb_object_keys(val2) k2 ON k1 = k2
    -- The WHERE clause filters for keys where the value has actually changed.
    WHERE val1 -> COALESCE(k1, k2) IS DISTINCT FROM val2 -> COALESCE(k1, k2);

    -- Return the result, or an empty JSON array if no differences were found.
    RETURN COALESCE(result, '[]'::jsonb);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.log_audit()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    -- Variáveis para armazenar os dados do registro antes e depois da alteração.
    old_data JSONB;
    new_data JSONB;
    -- Variável para armazenar o ID do usuário autenticado.
    user_id UUID;
BEGIN
    -- Tenta obter o ID do usuário a partir do contexto de autenticação do Supabase.
    -- A função auth.uid() retorna o UUID do usuário logado na sessão atual.
    -- Se não houver usuário logado (ex: uma operação do sistema), o valor será NULL.
    user_id := auth.uid();

    -- Condicional para a operação de INSERT (criação de um novo registro).
    IF (TG_OP = 'INSERT') THEN
        -- 'new_data' recebe o novo registro completo em formato JSONB.
        new_data := to_jsonb(NEW);
        -- 'old_data' é nulo, pois não há estado anterior.
        old_data := NULL;

    -- Condicional para a operação de UPDATE (alteração de um registro existente).
    ELSIF (TG_OP = 'UPDATE') THEN
        -- 'new_data' recebe o registro com as alterações.
        new_data := to_jsonb(NEW);
        -- 'old_data' recebe o registro como ele era antes da alteração.
        old_data := to_jsonb(OLD);

    -- Condicional para a operação de DELETE (exclusão de um registro).
    ELSIF (TG_OP = 'DELETE') THEN
        -- 'new_data' é nulo, pois o registro não existe mais.
        new_data := NULL;
        -- 'old_data' recebe o registro que foi excluído.
        old_data := to_jsonb(OLD);
    END IF;

    -- Insere o evento de auditoria na tabela 'audit_logs'.
    INSERT INTO public.audit_logs (
        user_id,
        action,
        table_name,
        record_id,
        old_record,
        new_record
    )
    VALUES (
        user_id,                                -- O ID do usuário que fez a ação.
        TG_OP,                                  -- A operação: 'INSERT', 'UPDATE' ou 'DELETE'.
        TG_TABLE_NAME,                          -- O nome da tabela onde a ação ocorreu.
        COALESCE(NEW.id, OLD.id),               -- O ID do registro afetado.
        old_data,                               -- O estado do registro antes da mudança.
        new_data                                -- O estado do registro depois da mudança.
    );

    -- Retorna o registro (NEW para INSERT/UPDATE, OLD para DELETE) para que a operação original continue.
    RETURN COALESCE(NEW, OLD);
END;
$function$
;

create or replace view "public"."relatos_with_responsibles_view" as  SELECT id,
    created_at,
    user_id,
    is_anonymous,
    local_ocorrencia,
    data_ocorrencia,
    hora_aproximada_ocorrencia,
    descricao,
    riscos_identificados,
    danos_ocorridos,
    status,
    planejamento_cronologia_solucao,
    data_conclusao_solucao,
    relato_code,
    ( SELECT json_agg(json_build_object('id', p.id, 'full_name', p.full_name, 'email', p.email)) AS json_agg
           FROM (relato_responsaveis rr
             JOIN profiles p ON ((rr.user_id = p.id)))
          WHERE (rr.relato_id = r.id)) AS responsibles_details
   FROM relatos r;


CREATE OR REPLACE FUNCTION public.search_relatos_unaccented(p_search_term text DEFAULT NULL::text, p_status_filter text DEFAULT NULL::text, p_responsible_filter text DEFAULT NULL::text, p_start_date date DEFAULT NULL::date, p_end_date date DEFAULT NULL::date, p_tipo_relato_filter text DEFAULT NULL::text)
 RETURNS TABLE(id uuid, created_at timestamp with time zone, local_ocorrencia text, descricao text, riscos_identificados text, danos_ocorridos text, planejamento_cronologia_solucao text, status text, data_conclusao_solucao timestamp with time zone, relato_code text, is_anonymous boolean, tipo_relato text, data_ocorrencia timestamp with time zone)
 LANGUAGE plpgsql
AS $function$
DECLARE
    search_query text := '%' || unaccent(p_search_term) || '%';
    final_query text;
BEGIN
    final_query := 'SELECT
        r.id,
        r.created_at,
        r.local_ocorrencia,
        r.descricao,
        r.riscos_identificados,
        r.danos_ocorridos,
        r.planejamento_cronologia_solucao,
        r.status,
        r.data_conclusao_solucao::TIMESTAMP WITH TIME ZONE,
        r.relato_code,
        r.is_anonymous,
        r.tipo_relato,
        r.data_ocorrencia::TIMESTAMP WITH TIME ZONE
    FROM public.relatos r WHERE 1=1';

    -- Aplica filtro de termo de pesquisa
    IF p_search_term IS NOT NULL AND p_search_term != '' THEN
        final_query := final_query || ' AND (
            unaccent(r.local_ocorrencia) ILIKE ' || quote_literal(search_query) || ' OR
            unaccent(r.descricao) ILIKE ' || quote_literal(search_query) || ' OR
            unaccent(r.riscos_identificados) ILIKE ' || quote_literal(search_query) || ' OR
            unaccent(r.danos_ocorridos) ILIKE ' || quote_literal(search_query) || ' OR
            unaccent(r.planejamento_cronologia_solucao) ILIKE ' || quote_literal(search_query) || ' OR
            r.relato_code ILIKE ' || quote_literal(search_query) || '
        )';
    END IF;

    -- Aplica filtro de status
    IF p_status_filter IS NOT NULL THEN
        IF p_status_filter = 'APROVADO' THEN
            final_query := final_query || ' AND r.status = ' || quote_literal('APROVADO');
        ELSIF p_status_filter = 'PENDENTE' THEN
            final_query := final_query || ' AND r.status = ' || quote_literal('PENDENTE');
        ELSIF p_status_filter = 'REPROVADO' THEN
            final_query := final_query || ' AND r.status = ' || quote_literal('REPROVADO');
        ELSIF p_status_filter = 'CONCLUIDO' THEN
            final_query := final_query || ' AND (r.data_conclusao_solucao IS NOT NULL OR r.concluido_sem_data = TRUE)';
        ELSIF p_status_filter = 'EM_ANDAMENTO' THEN
            final_query := final_query || ' AND r.planejamento_cronologia_solucao IS NOT NULL AND r.data_conclusao_solucao IS NULL AND r.concluido_sem_data = FALSE';
        ELSIF p_status_filter = 'SEM_TRATATIVA' THEN
            final_query := final_query || ' AND r.planejamento_cronologia_solucao IS NULL AND r.data_conclusao_solucao IS NULL AND r.concluido_sem_data = FALSE';
        END IF;
    END IF;

    -- Aplica filtro de tipo de relato (NOVO)
    IF p_tipo_relato_filter IS NOT NULL AND p_tipo_relato_filter != '' THEN
        IF p_tipo_relato_filter = 'Sem Classificação' THEN
            final_query := final_query || ' AND r.tipo_relato IS NULL';
        ELSE
            final_query := final_query || ' AND r.tipo_relato ILIKE ' || quote_literal(p_tipo_relato_filter);
        END IF;
    END IF;

    -- Aplica filtro de responsáveis
    IF p_responsible_filter IS NOT NULL AND p_responsible_filter != 'all' THEN
        IF p_responsible_filter = 'with_responsibles' THEN
            final_query := final_query || ' AND EXISTS (SELECT 1 FROM public.relato_responsaveis rr WHERE rr.relato_id = r.id)';
        ELSIF p_responsible_filter = 'without_responsibles' THEN
            final_query := final_query || ' AND NOT EXISTS (SELECT 1 FROM public.relato_responsaveis rr WHERE rr.relato_id = r.id)';
        END IF;
    END IF;

    -- Aplica filtro de data
    IF p_start_date IS NOT NULL AND p_end_date IS NOT NULL THEN
        final_query := final_query || ' AND r.data_ocorrencia BETWEEN ' || quote_literal(p_start_date) || ' AND ' || quote_literal(p_end_date);
    END IF;

    final_query := final_query || ' ORDER BY r.created_at DESC';

    RETURN QUERY EXECUTE final_query;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.search_relatos_unaccented(p_search_term text DEFAULT NULL::text, p_status_filter text DEFAULT NULL::text, p_responsible_filter text DEFAULT NULL::text, p_start_date date DEFAULT NULL::date, p_end_date date DEFAULT NULL::date, p_tipo_relato_filter text DEFAULT NULL::text, p_only_mine boolean DEFAULT false)
 RETURNS TABLE(id uuid, created_at timestamp with time zone, local_ocorrencia text, descricao text, riscos_identificados text, danos_ocorridos text, planejamento_cronologia_solucao text, status text, data_conclusao_solucao timestamp with time zone, relato_code text, is_anonymous boolean, tipo_relato text, data_ocorrencia timestamp with time zone)
 LANGUAGE plpgsql
AS $function$
DECLARE
    search_query text := '%' || unaccent(p_search_term) || '%';
    final_query text;
BEGIN
    final_query := 'SELECT
        r.id,
        r.created_at,
        r.local_ocorrencia,
        r.descricao,
        r.riscos_identificados,
        r.danos_ocorridos,
        r.planejamento_cronologia_solucao,
        r.status,
        r.data_conclusao_solucao::TIMESTAMP WITH TIME ZONE,
        r.relato_code,
        r.is_anonymous,
        r.tipo_relato,
        r.data_ocorrencia::TIMESTAMP WITH TIME ZONE
    FROM public.relatos r WHERE 1=1';

    -- Aplica filtro de termo de pesquisa
    IF p_search_term IS NOT NULL AND p_search_term != '' THEN
        final_query := final_query || ' AND (
            unaccent(r.local_ocorrencia) ILIKE ' || quote_literal(search_query) || ' OR
            unaccent(r.descricao) ILIKE ' || quote_literal(search_query) || ' OR
            unaccent(r.riscos_identificados) ILIKE ' || quote_literal(search_query) || ' OR
            unaccent(r.danos_ocorridos) ILIKE ' || quote_literal(search_query) || ' OR
            unaccent(r.planejamento_cronologia_solucao) ILIKE ' || quote_literal(search_query) || ' OR
            r.relato_code ILIKE ' || quote_literal(search_query) || ' 
        )';
    END IF;

    -- Aplica filtro de status
    IF p_status_filter IS NOT NULL THEN
        IF p_status_filter = 'APROVADO' THEN
            final_query := final_query || ' AND r.status = ' || quote_literal('APROVADO');
        ELSIF p_status_filter = 'PENDENTE' THEN
            final_query := final_query || ' AND r.status = ' || quote_literal('PENDENTE');
        ELSIF p_status_filter = 'REPROVADO' THEN
            final_query := final_query || ' AND r.status = ' || quote_literal('REPROVADO');
        ELSIF p_status_filter = 'CONCLUIDO' THEN
            final_query := final_query || ' AND r.data_conclusao_solucao IS NOT NULL';
        ELSIF p_status_filter = 'EM_ANDAMENTO' THEN
            final_query := final_query || ' AND r.planejamento_cronologia_solucao IS NOT NULL AND r.data_conclusao_solucao IS NULL';
        ELSIF p_status_filter = 'SEM_TRATATIVA' THEN
            final_query := final_query || ' AND r.planejamento_cronologia_solucao IS NULL AND r.data_conclusao_solucao IS NULL';
        END IF;
    END IF;

    -- Aplica filtro de tipo de relato (NOVO)
    IF p_tipo_relato_filter IS NOT NULL AND p_tipo_relato_filter != '' THEN
        IF p_tipo_relato_filter = 'Sem Classificação' THEN
            final_query := final_query || ' AND r.tipo_relato IS NULL';
        ELSE
            final_query := final_query || ' AND r.tipo_relato ILIKE ' || quote_literal(p_tipo_relato_filter);
        END IF;
    END IF;

    -- Aplica filtro de responsáveis
    IF p_responsible_filter IS NOT NULL AND p_responsible_filter != 'all' THEN
        IF p_responsible_filter = 'with_responsibles' THEN
            final_query := final_query || ' AND EXISTS (SELECT 1 FROM public.relato_responsaveis rr WHERE rr.relato_id = r.id)';
        ELSIF p_responsible_filter = 'without_responsibles' THEN
            final_query := final_query || ' AND NOT EXISTS (SELECT 1 FROM public.relato_responsaveis rr WHERE rr.relato_id = r.id)';
        END IF;
    END IF;

    -- Aplica filtro de data
    IF p_start_date IS NOT NULL AND p_end_date IS NOT NULL THEN
        final_query := final_query || ' AND r.data_ocorrencia BETWEEN ' || quote_literal(p_start_date) || ' AND ' || quote_literal(p_end_date);
    END IF;

    -- Aplica filtro para relatos do próprio usuário
    IF p_only_mine THEN
        final_query := final_query || ' AND r.user_id = auth.uid()';
    END IF;

    final_query := final_query || ' ORDER BY r.created_at DESC';

    RETURN QUERY EXECUTE final_query;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.search_relatos_unaccented(p_search_term text DEFAULT NULL::text, p_status_filter text DEFAULT NULL::text, p_responsible_filter text DEFAULT NULL::text, p_start_date date DEFAULT NULL::date, p_end_date date DEFAULT NULL::date, p_tipo_relato_filter text DEFAULT NULL::text, p_only_mine boolean DEFAULT false, p_page_number integer DEFAULT 1, p_page_size integer DEFAULT 20)
 RETURNS TABLE(id uuid, created_at timestamp with time zone, local_ocorrencia text, descricao text, riscos_identificados text, danos_ocorridos text, planejamento_cronologia_solucao text, status text, data_conclusao_solucao timestamp with time zone, relato_code text, is_anonymous boolean, tipo_relato text, data_ocorrencia timestamp with time zone, concluido_sem_data boolean, total_count bigint)
 LANGUAGE plpgsql
AS $function$
DECLARE
    search_query text := '%' || unaccent(p_search_term) || '%';
    query_conditions text := 'WHERE 1=1';
    final_query text;
    v_offset integer;
BEGIN
    v_offset := (p_page_number - 1) * p_page_size;

    -- Aplica filtro de termo de pesquisa
    IF p_search_term IS NOT NULL AND p_search_term != '' THEN
        query_conditions := query_conditions || ' AND (
            unaccent(r.local_ocorrencia) ILIKE ' || quote_literal(search_query) || ' OR
            unaccent(r.descricao) ILIKE ' || quote_literal(search_query) || ' OR
            unaccent(r.riscos_identificados) ILIKE ' || quote_literal(search_query) || ' OR
            unaccent(r.danos_ocorridos) ILIKE ' || quote_literal(search_query) || ' OR
            unaccent(r.planejamento_cronologia_solucao) ILIKE ' || quote_literal(search_query) || ' OR
            r.relato_code ILIKE ' || quote_literal(search_query) || '
        )';
    END IF;

    -- Aplica filtro de status
    IF p_status_filter IS NOT NULL THEN
        IF p_status_filter = 'APROVADO' THEN
            query_conditions := query_conditions || ' AND r.status = ' || quote_literal('APROVADO');
        ELSIF p_status_filter = 'PENDENTE' THEN
            query_conditions := query_conditions || ' AND r.status = ' || quote_literal('PENDENTE');
        ELSIF p_status_filter = 'REPROVADO' THEN
            query_conditions := query_conditions || ' AND r.status = ' || quote_literal('REPROVADO');
        ELSIF p_status_filter = 'CONCLUIDO' THEN
            query_conditions := query_conditions || ' AND r.status = ' || quote_literal('APROVADO') || ' AND (r.data_conclusao_solucao IS NOT NULL OR r.concluido_sem_data = TRUE)';
        ELSIF p_status_filter = 'EM_ANDAMENTO' THEN
            query_conditions := query_conditions || ' AND r.status = ' || quote_literal('APROVADO') || ' AND r.planejamento_cronologia_solucao IS NOT NULL AND r.data_conclusao_solucao IS NULL AND (r.concluido_sem_data IS NULL OR r.concluido_sem_data = FALSE)';
        ELSIF p_status_filter = 'SEM_TRATATIVA' THEN
            query_conditions := query_conditions || ' AND r.status = ' || quote_literal('APROVADO') || ' AND r.planejamento_cronologia_solucao IS NULL AND r.data_conclusao_solucao IS NULL AND (r.concluido_sem_data IS NULL OR r.concluido_sem_data = FALSE)';
        END IF;
    END IF;

    -- Aplica filtro de tipo de relato
    IF p_tipo_relato_filter IS NOT NULL AND p_tipo_relato_filter != '' THEN
        IF p_tipo_relato_filter = 'Sem Classificação' THEN
            query_conditions := query_conditions || ' AND r.tipo_relato IS NULL';
        ELSE
            query_conditions := query_conditions || ' AND r.tipo_relato ILIKE ' || quote_literal(p_tipo_relato_filter);
        END IF;
    END IF;

    -- Aplica filtro de responsáveis
    IF p_responsible_filter IS NOT NULL AND p_responsible_filter != 'all' THEN
        IF p_responsible_filter = 'with_responsibles' THEN
            query_conditions := query_conditions || ' AND EXISTS (SELECT 1 FROM public.relato_responsaveis rr WHERE rr.relato_id = r.id)';
        ELSIF p_responsible_filter = 'without_responsibles' THEN
            query_conditions := query_conditions || ' AND NOT EXISTS (SELECT 1 FROM public.relato_responsaveis rr WHERE rr.relato_id = r.id)';
        END IF;
    END IF;

    -- Aplica filtro de data
    IF p_start_date IS NOT NULL AND p_end_date IS NOT NULL THEN
        query_conditions := query_conditions || ' AND r.data_ocorrencia BETWEEN ' || quote_literal(p_start_date) || ' AND ' || quote_literal(p_end_date);
    END IF;

    -- Aplica filtro para relatos do próprio usuário
    IF p_only_mine THEN
        query_conditions := query_conditions || ' AND r.user_id = auth.uid()';
    END IF;

    final_query := '
        WITH filtered_relatos AS (
            SELECT *
            FROM public.relatos r
            ' || query_conditions || '
        )
        SELECT
            fr.id,
            fr.created_at,
            fr.local_ocorrencia,
            fr.descricao,
            fr.riscos_identificados,
            fr.danos_ocorridos,
            fr.planejamento_cronologia_solucao,
            fr.status,
            fr.data_conclusao_solucao::TIMESTAMP WITH TIME ZONE,
            fr.relato_code,
            fr.is_anonymous,
            fr.tipo_relato,
            fr.data_ocorrencia::TIMESTAMP WITH TIME ZONE,
            fr.concluido_sem_data, -- Adicionado
            (SELECT COUNT(*) FROM filtered_relatos) AS total_count
        FROM filtered_relatos fr
        ORDER BY fr.created_at DESC
        LIMIT ' || p_page_size || ' OFFSET ' || v_offset;

    RETURN QUERY EXECUTE final_query;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.set_updated_at_timestamp()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.sync_user_email_to_profiles()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  -- Verifica se o email foi alterado
  IF OLD.email IS DISTINCT FROM NEW.email THEN
    UPDATE public.profiles
    SET email = NEW.email
    WHERE id = NEW.id;
  END IF;
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_relato_responsaveis(p_relato_id uuid, p_user_ids uuid[])
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
    -- Etapa 1: Remove todos os responsáveis existentes para o relato informado.
    DELETE FROM public.relato_responsaveis
    WHERE relato_id = p_relato_id;

    -- Etapa 2: Insere a nova lista de responsáveis a partir do array fornecido.
    -- A função unnest expande o array em um conjunto de linhas.
    IF array_length(p_user_ids, 1) > 0 THEN
        INSERT INTO public.relato_responsaveis (relato_id, user_id)
        SELECT p_relato_id, unnested_user_id
        FROM unnest(p_user_ids) AS unnested_user_id;
    END IF;
END;
$function$
;


  create policy "Allow authorized users to read audit logs"
  on "public"."audit_logs"
  as permissive
  for select
  to public
using ((can_i_view_audit_logs() = true));



  create policy "Allow authenticated users to insert feedback reports"
  on "public"."feedback_reports"
  as permissive
  for insert
  to public
with check ((auth.role() = 'authenticated'::text));



  create policy "Allow users with can_view_feedbacks to update report status"
  on "public"."feedback_reports"
  as permissive
  for update
  to public
using ((EXISTS ( SELECT 1
   FROM profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.can_view_feedbacks = true)))))
with check ((EXISTS ( SELECT 1
   FROM profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.can_view_feedbacks = true)))));



  create policy "Allow users with can_view_feedbacks to view all reports"
  on "public"."feedback_reports"
  as permissive
  for select
  to public
using ((EXISTS ( SELECT 1
   FROM profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.can_view_feedbacks = true)))));



  create policy "Allow all authenticated users to view all profiles (fixed)"
  on "public"."profiles"
  as permissive
  for select
  to public
using (true);



  create policy "Allow users to insert their own profile"
  on "public"."profiles"
  as permissive
  for insert
  to authenticated
with check ((auth.uid() = id));



  create policy "profiles_delete_by_deleter"
  on "public"."profiles"
  as permissive
  for delete
  to authenticated
using (((EXISTS ( SELECT 1
   FROM profiles profiles_1
  WHERE ((profiles_1.id = auth.uid()) AND (profiles_1.can_delete_users = true)))) AND (auth.uid() <> id) AND (can_manage_users = false)));



  create policy "profiles_insert_by_creator"
  on "public"."profiles"
  as permissive
  for insert
  to authenticated
with check (((EXISTS ( SELECT 1
   FROM profiles profiles_1
  WHERE ((profiles_1.id = auth.uid()) AND (profiles_1.can_create_users = true)))) AND (can_manage_users = false)));



  create policy "profiles_update_roles_by_manager"
  on "public"."profiles"
  as permissive
  for update
  to authenticated
using (((EXISTS ( SELECT 1
   FROM profiles profiles_1
  WHERE ((profiles_1.id = auth.uid()) AND (profiles_1.can_manage_users = true)))) AND (auth.uid() <> id)))
with check (((email = email) AND (full_name = full_name) AND (created_at = created_at) AND (can_manage_users = can_manage_users)));



  create policy "Allow authenticated users to insert comments"
  on "public"."relato_comentarios"
  as permissive
  for insert
  to authenticated
with check (((auth.uid() = user_id) AND (EXISTS ( SELECT 1
   FROM relatos
  WHERE (relatos.id = relato_comentarios.relato_id)))));



  create policy "Allow authenticated users to read comments for accessible relat"
  on "public"."relato_comentarios"
  as permissive
  for select
  to authenticated
using ((EXISTS ( SELECT 1
   FROM relatos
  WHERE (relatos.id = relato_comentarios.relato_id))));



  create policy "Allow users to delete their own comments or if they can delete "
  on "public"."relato_comentarios"
  as permissive
  for delete
  to authenticated
using (((auth.uid() = user_id) OR (EXISTS ( SELECT 1
   FROM profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.can_delete_any_comment = true))))));



  create policy "Allow users to update their own comments"
  on "public"."relato_comentarios"
  as permissive
  for update
  to authenticated
using ((auth.uid() = user_id));



  create policy "Allow users to create relato_logs based on authentication statu"
  on "public"."relato_logs"
  as permissive
  for insert
  to public
with check ((((auth.uid() IS NOT NULL) AND (user_id = auth.uid())) OR ((auth.uid() IS NULL) AND (user_id IS NULL))));



  create policy "Usuários autenticados podem criar logs"
  on "public"."relato_logs"
  as permissive
  for insert
  to public
with check ((auth.role() = 'authenticated'::text));



  create policy "Usuários podem ver logs de relatos que eles acessam"
  on "public"."relato_logs"
  as permissive
  for select
  to public
using (((auth.role() = 'authenticated'::text) AND (EXISTS ( SELECT 1
   FROM relatos
  WHERE (relatos.id = relato_logs.relato_id)))));



  create policy "Admins can manage relato responsibles"
  on "public"."relato_responsaveis"
  as permissive
  for all
  to public
using ((EXISTS ( SELECT 1
   FROM profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.can_manage_relatos = true)))));



  create policy "Allow authenticated users to read all relato responsibles"
  on "public"."relato_responsaveis"
  as permissive
  for select
  to authenticated
using (true);



  create policy "Allow all users to insert relatos"
  on "public"."relatos"
  as permissive
  for insert
  to public
with check (true);



  create policy "Allow anon select (but returns no rows)"
  on "public"."relatos"
  as permissive
  for select
  to anon
using (false);



  create policy "Allow anonymous inserts"
  on "public"."relatos"
  as permissive
  for insert
  to anon
with check (true);



  create policy "Allow individual access for authenticated users"
  on "public"."relatos"
  as permissive
  for all
  to authenticated
using ((auth.uid() = user_id))
with check (((auth.uid() = user_id) OR (user_id IS NULL)));



  create policy "Allow update for managers or assigned responsibles"
  on "public"."relatos"
  as permissive
  for update
  to public
using ((( SELECT profiles.can_manage_relatos
   FROM profiles
  WHERE (profiles.id = auth.uid())) OR (EXISTS ( SELECT 1
   FROM relato_responsaveis rr
  WHERE ((rr.relato_id = relatos.id) AND (rr.user_id = auth.uid()))))))
with check ((( SELECT profiles.can_manage_relatos
   FROM profiles
  WHERE (profiles.id = auth.uid())) OR (EXISTS ( SELECT 1
   FROM relato_responsaveis rr
  WHERE ((rr.relato_id = relatos.id) AND (rr.user_id = auth.uid()))))));



  create policy "Allow users with can_delete_relatos permission to delete relato"
  on "public"."relatos"
  as permissive
  for delete
  to public
using ((auth.uid() IN ( SELECT profiles.id
   FROM profiles
  WHERE (profiles.can_delete_relatos = true))));



  create policy "Enable select for users based on permissions"
  on "public"."relatos"
  as permissive
  for select
  to public
using (((( SELECT profiles.can_view_all_relatos
   FROM profiles
  WHERE (profiles.id = auth.uid())) = true) OR (user_id = auth.uid()) OR (EXISTS ( SELECT 1
   FROM relato_responsaveis
  WHERE ((relato_responsaveis.relato_id = relatos.id) AND (relato_responsaveis.user_id = auth.uid()))))));


CREATE TRIGGER relatos_audit_trigger AFTER INSERT OR DELETE OR UPDATE ON public.relatos FOR EACH ROW EXECUTE FUNCTION log_audit();

CREATE TRIGGER set_relato_code BEFORE INSERT ON public.relatos FOR EACH ROW EXECUTE FUNCTION generate_relato_code();


